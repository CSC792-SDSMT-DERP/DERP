# Required class components for a new module

## Implementing a Module
The module class should extend [IModule](../derp/modules/IModule.py) and implement the following methods:
  - `def name(self):`
    - This method returns the name of the module, modules that are loaded must have distinct names when lowercase
  - `def source_grammar(self):`
    - This method returns a Grammar object created with a dictionary mapping Lark rules and tokens to their production rules
      - Lark rule names use lowercase letters only; Lark token names use uppercase letters only
      - There must exist at least one rule or token named `<modulename>_source` in all uppercase or lowercase letters
        - This is the start symbol for the module grammar
        - This symbol must not begin with an underscore or a question mark.
        - No productions for this symbol can contain '->' (The Lark alias marker)
      - Additional information about Lark grammars may be found on [their GitHub page](https://github.com/lark-parser/lark)
  - `def post_definition(self):`
    - Must return a [PostDefinition](../derp/posts/PostDefinition.py) object that specifies the names of the fields that may be read on resulting posts
      - This definition contains a set of field names and the data type associated with each field.
      - This is done by passing a dictionary mapping the string with the field's name to the type into the PostDefinition constructor.
      - Data types ***must*** be from the `FieldType` enum found with the `PostDefinition` class
      - All posts returned should meet this post definition. If they do not, they will be filtered incorrectly
  - `def get_posts(self, source_ast, qualifier_tree):`
    - Must return an iterable type over posts (An [IPostIterator](../derp/posts/IPostIterator.py))
      - A generator may be converted to such a type by returning `PostIterator(generator())`
    - source_ast describes which source in the module to retrieve posts from
      - This is a Lark Tree generated by matching the grammar returned by `source_grammar()`. The root node will be `<module name>_source`.
    - qualifier_tree specifies filters to apply to results, and may be used to pre-filter results
      - The qualifier tree consists of nodes specifying predicate logic on fields and their values
      - Qualifier Trees are discussed below, but the full definition can be found in [QualifierTree.py](../derp/qualifiers/QualifierTree.py)

## Implementing Posts
Posts returned by `get_posts()` must extend [IPost](../derp/posts/IPost.py) and implement the following methods:
  - `def definition(self):`
    - Returns the post definition for the post
    - This is the same definition defined in the `post_definition()` method of the module class
  - `def source(self):`
    - Returns the module object that created the post
  - `def field_data(self, field_name):`
    - Retrieve data from the field with the given name
    - This name is one of those specified in the post definition
    - If the post is otherwise unable to return data, it should return `None`, the Python `NoneType`
  - `def about(self, string):`
    - Module-defined method that should return true if the string matches information about the post
    - A simple implementation might check for the string in either the title or body of the post.
    - `about()` is invoked during the enforcement step after posts are retrieved from the iterable returned by `get_posts()`
      - If an external service implements a topial check which will filter posts before they are returned by the PostIterator, `about()` may simply return True
  - `def __str__(self):`
    - Returns the textual representation of the post 
    - The default terminal output will print the string returned by this method as-is

`about()` and `field_data()` will both be invoked during the enforcement step of a query. Regardless of what posts are returned by the `PostIterator`, they will be filtered by the DERP backend to ensure that they meet the user-specified criteria.
Modules are encouraged to use the qualifier tree to filter posts as part of their web query when possible; however as this is not required - the enforcement step is always performed.

## Testing your Module
### Running the Module Against the Module Interface Tests
  To verify that the module is meeting the required interface, create a pytest file
  with two pytest fixtures. The first, `module_impl()`, creates an instance of the module class, while
  the second, `module_source_string()`, returns the source string for the query made.

  These will be used when running the tests in [IModule_tests.py](../derp/modules/tests/IModule_tests.py).

#### Example of `module_impl()`
```Python
@pytest.fixture()
def module_impl():
    my_module_instance = MyModule(
        # constructor arguments go here
    )
    return my_module_instance
```

#### Example of `module_source_string()`
A valid source string consists of any input string that corresponds to a valid string defined by
the Grammar returned by `source_grammar()`.
```Python
@pytest.fixture(params['valid source string #1', 'valid source string #2'])
def module_source_string(request):
    return request.param
```

### Running a Post against the Post Interface Tests
  Similarly to the Module Interface, there are a set of tests that can be run to ensure that a Post
  matches the Post Interface. Testing the Post interface requires only a single fixture, `post_impl()`
  and gets tests from [IPost_tests.py](../derp/posts/tests/IPost_tests.py).

#### Example of `post_impl()`
```Python
@pytest.fixture()
def post_impl():
    my_post_instance = MyPost(
        # constructor arguments go here
    )
    return my_post_instance
```

## Registering a New Module
New Modules must be added to the derp.py script by instantiating an instance of the module class and
invoking the module controller's `register_module()` method with the class instance as an argument in the `main()` method.
This will make the module available for use with `load "modulename"` expressions.

# The Qualifier Tree
Qualifier trees are a tree representation of the predicate built in a selection. It combines all of the qualifiers used in `add` and `remove` statements which involve the source in question.

All nodes in the tree inherit from `QualifierTreeNode`. All nodes internal to the tree inherit from `ParentNode`. These are the nodes used to combine and/or negate other nodes. All other nodes inherit from `LeafNode`; these nodes indicate the actual checks to be performed on each post.

## `QualifierTreeNode`
  * `def evaluate(self, post)`
    * Returns True if the given post matches this tree (and it's children, when applicable)
  * `def __str__(self)`
    * Returns a string representation of the node, for debug purposes

## `ParentNode(QualifierTreeNode)`
  * `def children(self)`
    * Returns a tuple of all children of this node

## `AndNode(ParentNode)`
  Evaluates whether or not both children match a post
  * `def __init__(self, left_node, right_node)`

## `OrNode(ParentNode)`
  Evaluates whether or not either child matches a post
  * `def __init__(self, left_node, right_node)`
  
## `NotNode(ParentNode)`
  Evaluates whether or not the child does not match a post
  * `def __init__(self, child_node)`

## `LeafNode(QualifierTreeNode)`
  * `def data(self)`
    * Returns any arguments for the node. In all current cases, this returns a single value; but it could in the future be used to return a tuple

## `FieldCheckNode(LeafNode)`
  * `def field(self)`
    * Gets the name of the field to check

## `DateCheck(FieldCheckNode)`
  Indicates that the data in a specific post field should be compared to a date
  * `def data(self)`
    * Returns a Python `datetime.date`

## `DateOnCheck(DateCheck)`
  Indicates that the data in a specific post field should be on a specific day

## `DateAfterCheck(DateCheck)`
  Indicates that the data in a specific post field should be after a specific day

## `DateBeforeCheck(DateCheck)`
  Indicates that the data in a specific post field should be before a specific day

## `StringCheck(FieldCheckNode)`
  * `def data(self)`
    * Returns a Python `str`

## `SubstringCheck(StringCheck)`
  Indicates that a the data in a specific post field should contain a string

## `ExactStringCheck(StringCheck)`
  Indicates that a the data in a specific post field should match a string

## `NumberCheck(FieldCheckNode)`
  * `def data(self)`
    * Returns a Python `Number.number`
  
## `ExactNumberCheck(NumberCheck)`
  Indicates that a the data in a specific post field should equal a number

## `OverNumberCheck(NumberCheck)`
  Indicates that a the data in a specific post field should be greater than a number

## `UnderNumberCheck(NumberCheck)`
  Indicates that a the data in a specific post field should be less than than a number

## `BooleanCheck(FieldCheckNode)`
  Indicates that a the data in a specific post field should match a specific boolean value
  * `def data(self)`
    * Returns a Python `bool`

## `AboutCheck(LeafNode)`
  Indicates that a the data in a post should topically match some string
  * `def data(self)`
    * Returns a Python `str`